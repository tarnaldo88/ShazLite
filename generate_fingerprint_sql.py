#!/usr/bin/env python3
"""
Generate SQL INSERT statements with real audio fingerprints.
Run this script, then copy the output SQL into pgAdmin.
"""

import os
import sys
import numpy as np
from pathlib import Path
import hashlib

# Audio processing libraries
try:
    import librosa
    from scipy.signal import find_peaks
    print("‚úÖ Audio processing libraries loaded")
except ImportError as e:
    print(f"‚ùå Missing libraries: {e}")
    print("Install with: pip install librosa scipy matplotlib soundfile")
    sys.exit(1)

def extract_audio_fingerprints(file_path, song_id):
    """Extract real audio fingerprints using spectral analysis."""
    
    try:
        print(f"  üéµ Loading audio: {file_path.name}")
        
        # Load audio file (first 30 seconds)
        y, sr = librosa.load(file_path, sr=22050, duration=30)
        print(f"  üìä Loaded {len(y)/sr:.1f}s at {sr} Hz")
        
        # Compute spectrogram
        stft = librosa.stft(y, hop_length=512, n_fft=2048)
        magnitude = np.abs(stft)
        
        fingerprints = []
        hop_length = 512
        
        # Process every 0.1 seconds
        for t_idx in range(0, magnitude.shape[1] - 10, 10):
            spectrum = magnitude[:, t_idx]
            
            # Find spectral peaks
            peaks, _ = find_peaks(spectrum, height=np.max(spectrum) * 0.15, distance=10)
            
            if len(peaks) >= 2:
                # Sort by magnitude and take top peaks
                peak_magnitudes = spectrum[peaks]
                top_indices = np.argsort(peak_magnitudes)[-4:]  # Top 4 peaks
                top_peaks = peaks[top_indices]
                
                # Create fingerprint pairs
                for i in range(len(top_peaks)):
                    for j in range(i + 1, min(i + 3, len(top_peaks))):
                        freq1 = top_peaks[i]
                        freq2 = top_peaks[j]
                        
                        time_offset_ms = int((t_idx * hop_length / sr) * 1000)
                        
                        # Create unique hash
                        freq_diff = abs(freq2 - freq1)
                        hash_input = f"{song_id}_{freq1}_{freq2}_{freq_diff}_{time_offset_ms // 100}"
                        hash_value = int(hashlib.md5(hash_input.encode()).hexdigest()[:12], 16)
                        
                        # Convert to Hz
                        freq1_hz = freq1 * sr / (2 * magnitude.shape[0])
                        freq2_hz = freq2 * sr / (2 * magnitude.shape[0])
                        
                        fingerprints.append({
                            'song_id': song_id,
                            'hash_value': hash_value,
                            'time_offset_ms': time_offset_ms,
                            'frequency_1': freq1_hz,
                            'frequency_2': freq2_hz,
                            'time_delta_ms': abs(j - i) * 10
                        })
        
        print(f"  ‚úÖ Generated {len(fingerprints)} fingerprints")
        return fingerprints
        
    except Exception as e:
        print(f"  ‚ùå Error processing {file_path.name}: {e}")
        return []

def generate_sql_for_songs(folder_path):
    """Generate SQL INSERT statements for songs and fingerprints."""
    
    folder = Path(folder_path)
    if not folder.exists():
        print(f"‚ùå Folder not found: {folder_path}")
        return
    
    mp3_files = list(folder.glob("*.mp3")) + list(folder.glob("*.MP3"))
    
    if not mp3_files:
        print(f"‚ùå No MP3 files found in: {folder_path}")
        return
    
    print(f"üéµ Found {len(mp3_files)} MP3 files")
    print("=" * 60)
    
    # Generate SQL
    sql_output = []
    sql_output.append("-- Real Audio Fingerprints SQL")
    sql_output.append("-- Generated by generate_fingerprint_sql.py")
    sql_output.append("-- Copy and paste this into pgAdmin Query Tool")
    sql_output.append("")
    sql_output.append("-- Clear existing data (optional)")
    sql_output.append("-- DELETE FROM fingerprints;")
    sql_output.append("-- DELETE FROM songs;")
    sql_output.append("")
    sql_output.append("-- Insert songs")
    
    song_inserts = []
    fingerprint_inserts = []
    
    for i, file_path in enumerate(mp3_files, 1):
        print(f"\n[{i}/{len(mp3_files)}] Processing: {file_path.name}")
        
        # Extract metadata
        name = file_path.stem
        if ' - ' in name:
            parts = name.split(' - ', 1)
            artist = parts[0].strip()
            title = parts[1].strip()
        else:
            artist = "Unknown Artist"
            title = name
        
        print(f"  üé§ {artist} - {title}")
        
        # Escape single quotes for SQL
        title_sql = title.replace("'", "''")
        artist_sql = artist.replace("'", "''")
        
        song_inserts.append(f"('{title_sql}', '{artist_sql}', '', 180, 2024, 'Unknown')")
        
        # Generate fingerprints
        fingerprints = extract_audio_fingerprints(file_path, i)
        
        # Add fingerprint inserts
        for fp in fingerprints:
            fingerprint_inserts.append(
                f"({fp['song_id']}, {fp['hash_value']}, {fp['time_offset_ms']}, "
                f"{fp['frequency_1']:.2f}, {fp['frequency_2']:.2f}, {fp['time_delta_ms']})"
            )
    
    # Build complete SQL
    if song_inserts:
        sql_output.append("INSERT INTO songs (title, artist, album, duration_seconds, year, genre) VALUES")
        sql_output.append(",\n".join(song_inserts) + ";")
        sql_output.append("")
    
    if fingerprint_inserts:
        sql_output.append("-- Insert fingerprints")
        sql_output.append("INSERT INTO fingerprints (song_id, hash_value, time_offset_ms, frequency_1, frequency_2, time_delta_ms) VALUES")
        
        # Split into batches of 1000 for better performance
        batch_size = 1000
        for i in range(0, len(fingerprint_inserts), batch_size):
            batch = fingerprint_inserts[i:i + batch_size]
            sql_output.append(",\n".join(batch) + ";")
            sql_output.append("")
    
    # Add verification query
    sql_output.append("-- Verify the data")
    sql_output.append("SELECT s.id, s.title, s.artist, COUNT(f.id) as fingerprint_count")
    sql_output.append("FROM songs s")
    sql_output.append("LEFT JOIN fingerprints f ON s.id = f.song_id")
    sql_output.append("GROUP BY s.id, s.title, s.artist")
    sql_output.append("ORDER BY s.id;")
    
    # Write to file
    sql_content = "\n".join(sql_output)
    
    output_file = "real_fingerprints.sql"
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(sql_content)
    
    print("\n" + "=" * 60)
    print("üéâ SQL generation complete!")
    print(f"üìÑ SQL file created: {output_file}")
    print(f"üìä Total fingerprints: {len(fingerprint_inserts)}")
    print("\nüîß Next steps:")
    print("1. Open pgAdmin")
    print("2. Connect to your audio_fingerprinting database")
    print("3. Open Query Tool")
    print(f"4. Copy and paste the contents of '{output_file}'")
    print("5. Execute the SQL")
    print("6. Test your Qt app with real songs!")

def main():
    if len(sys.argv) < 2:
        print("Real Audio Fingerprinting SQL Generator")
        print("=" * 40)
        print("Usage: python generate_fingerprint_sql.py <music_folder_path>")
        print("\nExample:")
        print('python generate_fingerprint_sql.py "C:\\Users\\tarna\\Documents\\SongForShazlite"')
        print("\nThis generates SQL with REAL fingerprints for accurate song identification!")
        sys.exit(1)
    
    folder_path = sys.argv[1]
    generate_sql_for_songs(folder_path)

if __name__ == "__main__":
    main()